<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Twilight</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><a href="support.html">Support</a></li><li class="chapter-item expanded "><a href="chapter_1_crates/summary.html"><strong aria-hidden="true">1.</strong> Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1_crates/section_1_model.html"><strong aria-hidden="true">1.1.</strong> Model</a></li><li class="chapter-item expanded "><a href="chapter_1_crates/section_2_http.html"><strong aria-hidden="true">1.2.</strong> HTTP</a></li><li class="chapter-item expanded "><a href="chapter_1_crates/section_3_gateway.html"><strong aria-hidden="true">1.3.</strong> Gateway</a></li><li class="chapter-item expanded "><a href="chapter_1_crates/section_4_cache.html"><strong aria-hidden="true">1.4.</strong> Cache</a></li><li class="chapter-item expanded "><a href="chapter_1_crates/section_5_command_parser.html"><strong aria-hidden="true">1.5.</strong> Command Parser</a></li><li class="chapter-item expanded "><a href="chapter_1_crates/section_6_twilight.html"><strong aria-hidden="true">1.6.</strong> Twilight</a></li><li class="chapter-item expanded "><a href="chapter_1_crates/section_7_first_party/summary.html"><strong aria-hidden="true">1.7.</strong> First-party</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1_crates/section_7_first_party/section_1_cache_redis.html"><strong aria-hidden="true">1.7.1.</strong> Redis Cache</a></li><li class="chapter-item expanded "><a href="chapter_1_crates/section_7_first_party/section_2_lavalink.html"><strong aria-hidden="true">1.7.2.</strong> Lavalink</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_1_crates/section_8_third_party.html"><strong aria-hidden="true">1.8.</strong> Third-party</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2_building_a_bot/summary.html"><strong aria-hidden="true">2.</strong> Building a Bot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2_building_a_bot/section_1_preparation.html"><strong aria-hidden="true">2.1.</strong> Preparation</a></li><li class="chapter-item expanded "><a href="chapter_2_building_a_bot/section_2_pong.html"><strong aria-hidden="true">2.2.</strong> Pong!</a></li><li class="chapter-item expanded "><a href="chapter_2_building_a_bot/section_3_have_some_fun.html"><strong aria-hidden="true">2.3.</strong> Have Some Fun</a></li><li class="chapter-item expanded "><a href="chapter_2_building_a_bot/section_4_basic_moderation.html"><strong aria-hidden="true">2.4.</strong> Basic Moderation</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3_services/summary.html"><strong aria-hidden="true">3.</strong> Services</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3_services/section_1_why_build.html"><strong aria-hidden="true">3.1.</strong> Why Build Services?</a></li><li class="chapter-item expanded "><a href="chapter_3_services/section_2_using_http_proxy.html"><strong aria-hidden="true">3.2.</strong> Using an HTTP Proxy</a></li><li class="chapter-item expanded "><a href="chapter_3_services/section_3_using_redis.html"><strong aria-hidden="true">3.3.</strong> Using a Redis Cache</a></li><li class="chapter-item expanded "><a href="chapter_3_services/section_4_using_message_broker.html"><strong aria-hidden="true">3.4.</strong> Using a Message Broker</a></li><li class="chapter-item expanded "><a href="chapter_3_services/section_5_gateway_queue.html"><strong aria-hidden="true">3.5.</strong> Using the Gateway Queue</a></li><li class="chapter-item expanded "><a href="chapter_3_services/section_6_moving_forward.html"><strong aria-hidden="true">3.6.</strong> Moving Forward</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4_bots_using_twilight.html"><strong aria-hidden="true">4.</strong> Bots using Twilight</a></li><li class="chapter-item expanded "><a href="chapter_5_changelogs.html"><strong aria-hidden="true">5.</strong> Changelogs</a></li><li class="chapter-item expanded affix "><a href="contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Twilight</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<p><img
  src="https://raw.githubusercontent.com/twilight-rs/twilight/master/logo.png" 
  alt="twilight logo"
/></p>
<p><a href="https://discord.gg/WBdGJCc">Join us on Discord! :)</a></p>
<blockquote>
<p><strong>Warning</strong>: Twilight is still a work in progress, so while some of this stuff
exists <em>right now</em>, a lot of it doesn't. Features, APIs, and usage of crates
not completed is documented for design feedback. You shouldn't try building
something yet.</p>
</blockquote>
<p><strong>twilight</strong> is an ecosystem of asynchronous, unopinionated, and extensible
libraries for using the Discord APIs. It has the additional goals of simplicity,
fearless breaking changes where needed, and the embracing of third party
libraries.</p>
<h3><a class="header" href="#the-guide" id="the-guide">The Guide</a></h3>
<p>In this guide you'll learn about the core crates in the twilight ecosystem, useful
first-party crates for more advanced use cases, and third-party crates giving
you a tailored experience. You'll build a bot using all of the core crates
available, and learn why and how to use services for larger bots.</p>
<h3><a class="header" href="#links" id="links">Links</a></h3>
<p>The organization for the project is <a href="https://github.com/twilight-rs">on GitHub, named &quot;twilight-rs&quot;</a>.</p>
<p>The crates are available on <a href="https://crates.io/crates/twilight">crates.io</a>.</p>
<p>The API docs are also hosted for the <a href="https://docs.rs/twilight">latest version</a>.</p>
<p>There is a community and support server <a href="https://discord.gg/WBdGJCc">on Discord</a>.</p>
<h3><a class="header" href="#a-quick-example" id="a-quick-example">A Quick Example</a></h3>
<p>Below is a quick example of a program printing &quot;Pong!&quot; when a ping command comes
in from a channel:</p>
<pre><code class="language-rust ignore">use futures::StreamExt;
use twilight::{
    command_parser::{Command, Config as ParserConfig, Parser},
    gateway::{Config, Event, Shard},
};
use std::{
    env,
    error::Error,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let token = env::var(&quot;DISCORD_TOKEN&quot;)?;

    let shard = Shard::new(token).await?;

    let parser = {
        let mut config = Config::new();
        config.command(&quot;ping&quot;).add();
        config.add_prefix(&quot;!&quot;);
        Parser::new(config)
    };

    let mut events = shard.events().await;

    while let Some(event) = events.next().await {
        match event {
            Event::MessageCreate(msg) =&gt; match parser.parse(&amp;msg.content) {
                Command { name: &quot;ping&quot;, .. } =&gt; println!(&quot;Pong!&quot;),
                _ =&gt; {},
            },
            _ =&gt; {},
        }
    }
}
</code></pre>
<h1><a class="header" href="#support" id="support">Support</a></h1>
<p>Support for the library is provided through the <a href="https://github.com/twilight-rs/twilight/issues">GitHub issues</a> section and the
<a href="https://discord.gg/WBdGJCc">Discord server</a>.</p>
<p>If you have a question, then the issues or the server are both good fits for it.
If you find a bug, then the issues section is the best place.</p>
<p>The API documentation is <a href="https://docs.rs/twilight">also available</a>.</p>
<h3><a class="header" href="#supported-rust-versions" id="supported-rust-versions">Supported Rust Versions</a></h3>
<p>Twilight supports Rust versions 1.39 and above.</p>
<h3><a class="header" href="#breaking-changes" id="breaking-changes">Breaking Changes</a></h3>
<p>Although Twilight aims to design APIs right the first time, that obviously won't
happen. A lot of care is taken into designing them in an unopinionated way,
leaving more opinionated concepts to userland libraries.</p>
<p>While Twilight takes care to avoid the need for breaking changes, it will be
fearless when it needs to: they won't be avoided for the sake of avoiding a
change. Breaking changes won't be piled up over the course of a long time, so
when upgrades need to happen they will be quick and painless.</p>
<h1><a class="header" href="#crates" id="crates">Crates</a></h1>
<p>Twilight is, at heart, an ecosystem. These components of the ecosystem generally,
for the most part, don't depend on each other. The crates in it are sectioned
into three &quot;parts&quot;: the <em>core crates</em>, <em>first-party crates</em>, and <em>third-party
crates</em>.</p>
<h3><a class="header" href="#core-crates" id="core-crates">Core Crates</a></h3>
<p>Twilight includes a few crates which are the &quot;building blocks&quot; to your success. You
might not need them all, but generally speaking you'll need most of them for
your use case. Most of them wrap Discord's various APIs.</p>
<ul>
<li><em>model</em>: All of the structs, enums, and bitflags used by the Discord APIs.</li>
<li><em>http</em>: An HTTP client supporting all of the documented features of Discord's
HTTP API, with support for ratelimiting, proxying, and more.</li>
<li><em>gateway</em>: A client supporting Discord's gateway API.</li>
<li><em>cache</em>: Definitions for implementating a cache. An in-process memory
implementation is included.</li>
<li><em>voice</em>: A client supporting Discord's voice API.</li>
<li><em>command-parser</em>: A basic command parser for parsing commands and arguments
out of messages.</li>
<li><em>twilight</em>: The root crate, re-exporting all of the other core crates in one
unified crate.</li>
</ul>
<h3><a class="header" href="#first-party-crates" id="first-party-crates">First-Party Crates</a></h3>
<p>Additionally, there are some first-party crates maintained by the Twilight
organization, but not included in the core experience. These might be for more
advanced use cases or clients for third-party services. Two examples of
first-party crates are <code>twilight-cache-redis</code> - an implementation of a cache using
Redis as a backend - and <code>twilight-lavalink</code>, an implementation of a client for
Lavalink.</p>
<h3><a class="header" href="#third-party-crates" id="third-party-crates">Third-Party Crates</a></h3>
<p>Third-party crates may start to exist over time. These aren't officially
supported by the Twilight organization, and are maintained by other people.</p>
<p>These are currently no third-party crates. I mean, this thing isn't even at 0.1
yet.</p>
<h1><a class="header" href="#model" id="model">Model</a></h1>
<p><code>twilight-model</code> is a crate of only serde models defining the Discord APIs with
no implementations on top of them or functions to work with them.</p>
<p>These are in a single crate for ease of use, a single point of definition,
and a sort of versioning of the Discord API. Similar to how a database
schema progresses in versions, the definition of the API also progresses in
versions.</p>
<p>The types in this crate are reproducible: deserializing a payload into a
type, serializing it, and then deserializing it again will work.</p>
<p>Defined are a number of modules defining types returned by or owned by
resource categories. For example, <code>gateway</code> are types used to interact with
and returned by the gateway API. <code>guild</code> contains types owned by the Guild
resource category. These types may be directly returned by, built on top of,
or extended by other crates.</p>
<h3><a class="header" href="#installation" id="installation">Installation</a></h3>
<p>This crate requires Rust 1.31+.</p>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">twilight-model = { git = &quot;https://github.com/twilight-rs/twilight&quot; }
</code></pre>
<h3><a class="header" href="#features" id="features">Features</a></h3>
<p><code>twilight-model</code> has a single feature, <code>serde-support</code>. By default it is enabled.
This enables serde support of the models, which brings in four dependencies:</p>
<ul>
<li><code>serde</code></li>
<li><code>serde_json</code></li>
<li><code>serde-mappable-seq</code></li>
<li><code>serde_repr</code></li>
</ul>
<p>If you don't need serde support, you can disable it:</p>
<pre><code class="language-toml">[dependencies]
twilight-model = { default-features = false, git = &quot;https://github.com/twilight-rs/twilight&quot; }
</code></pre>
<h3><a class="header" href="#links-1" id="links-1">Links</a></h3>
<p><em>source</em>: <a href="https://github.com/twilight-rs/twilight/tree/master/model">https://github.com/twilight-rs/twilight/tree/master/model</a></p>
<p><em>docs</em>: <a href="https://docs.rs/twilight-model">https://docs.rs/twilight-model</a></p>
<p><em>crates.io</em>: <a href="https://crates.io/crates/twilight-model">https://crates.io/crates/twilight-model</a></p>
<h1><a class="header" href="#http" id="http">HTTP</a></h1>
<p><code>twilight-http</code> is an HTTP client wrapping all of the documented Discord HTTP API.
It is built on top of <a href="https://github.com/seanmonstar/reqwest">Reqwest</a>, and supports taking any generic Reqwest client,
allowing you to pick your own TLS backend. By default, it uses OpenSLL, but it can be changed to use <a href="https://github.com/ctz/rustls">RusTLS</a> a Rust
TLS implementation.</p>
<p>Ratelimiting is included out-of-the-box, along with support for proxies.</p>
<h3><a class="header" href="#installation-1" id="installation-1">Installation</a></h3>
<p>This library requires at least Rust 1.39+.</p>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">twilight-http = { git = &quot;https://github.com/twilight-rs/twilight&quot; }
</code></pre>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<p>A quick example showing how to send 10 messages, and then print the current
user's name:</p>
<pre><pre class="playpen"><code class="language-rust">use futures::future;
use std::{env, error::Error};
use twilight_http::Client;
use twilight_model::id::ChannelId;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    pretty_env_logger::init_timed();

    let client = Client::new(env::var(&quot;DISCORD_TOKEN&quot;)?);
    let channel_id = ChannelId(381_926_291_785_383_946);

    future::join_all((1u8..=10).map(|x| {
        client
            .create_message(channel_id)
            .content(format!(&quot;Ping #{}&quot;, x))
    }))
    .await;

    let me = client.current_user().await?;
    println!(&quot;Current user: {}#{}&quot;, me.name, me.discriminator);

    Ok(())
}
</code></pre></pre>
<h3><a class="header" href="#links-2" id="links-2">Links</a></h3>
<p><em>source</em>: <a href="https://github.com/twilight-rs/twilight/tree/master/http">https://github.com/twilight-rs/twilight/tree/master/http</a></p>
<p><em>docs</em>: <a href="https://docs.rs/twilight-http">https://docs.rs/twilight-http</a></p>
<p><em>crates.io</em>: <a href="https://crates.io/crates/twilight-http">https://crates.io/crates/twilight-http</a></p>
<h1><a class="header" href="#gateway" id="gateway">Gateway</a></h1>
<p><code>twilight-gateway</code> is an implementation of a client over Discord's websocket
gateway.</p>
<p>The main type is the <code>Shard</code>: it connects to the gateway, receives messages,
parses and processes them, and then gives them to you. It will automatically
reconnect, resume, and identify, as well as do some additional connectivity
checks.</p>
<p>Also provided is the <code>Cluster</code>, which will automatically manage a collection of
shards and unify their messages into one stream. It doesn't have a large API --
pretty much just <code>up</code> and <code>down</code> to bring the cluster up or down. It implements
a stream which returns items of the ID of the shard a message came from, and the
parsed event representing it.</p>
<h3><a class="header" href="#installation-2" id="installation-2">Installation</a></h3>
<p>This library requires at least Rust 1.39+.</p>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">twilight-gateway = { git = &quot;https://github.com/twilight-rs/twilight&quot; }
</code></pre>
<h3><a class="header" href="#example-1" id="example-1">Example</a></h3>
<p>Starting a <code>Shard</code> and printing the contents of new messages as they come in:</p>
<pre><pre class="playpen"><code class="language-rust">use futures::StreamExt;
use std::{env, error::Error};
use twilight_gateway::Shard;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    pretty_env_logger::init_timed();

    let shard = Shard::new(env::var(&quot;DISCORD_TOKEN&quot;)?).await?;
    println!(&quot;Created shard&quot;);

    let mut events = shard.events().await;

    while let Some(event) = events.next().await {
        println!(&quot;Event: {:?}&quot;, event);
    }

    Ok(())
}
</code></pre></pre>
<h3><a class="header" href="#links-3" id="links-3">Links</a></h3>
<p><em>source</em>: <a href="https://github.com/twilight-rs/twilight/tree/master/gateway">https://github.com/twilight-rs/twilight/tree/master/gateway</a></p>
<p><em>docs</em>: <a href="https://docs.rs/twilight-gateway">https://docs.rs/twilight-gateway</a></p>
<p><em>crates.io</em>: <a href="https://crates.io/crates/twilight-gateway">https://crates.io/crates/twilight-gateway</a></p>
<h1><a class="header" href="#cache" id="cache">Cache</a></h1>
<h1><a class="header" href="#command-parser" id="command-parser">Command Parser</a></h1>
<p>The Command Parser is a basic parser for the Twilight ecosystem. We'll get this out
of the way first: it's not a framework, and it doesn't try to be.</p>
<p>The parser, for the most part, takes a configuration of prefixes and commands,
and attempts to match it to provided strings, returning what command and prefix
it matched, if any. The parser will also return a lazy iterator of arguments
given to the command.</p>
<p>Included is a mutable configuration that allows you to specify the command
names, prefixes, and ignored guilds and users. The parser parses out commands
matching an available command and prefix and provides the command arguments to
you.</p>
<h3><a class="header" href="#installation-3" id="installation-3">Installation</a></h3>
<p>Add the following to your Cargo.toml:</p>
<pre><code class="language-toml">[dependencies]
twilight-command-parser = { git = &quot;https://github.com/twilight-rs/twilight&quot; }
</code></pre>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<p>A simple parser for a bot with one prefix (<code>&quot;!&quot;</code>) and two commands, <code>&quot;echo&quot;</code>
and <code>&quot;ping&quot;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use twilight_command_parser::{Command, Config, Parser};

let mut config = Config::new();

// (Use `Config::add_command` to add a single command)
config.command(&quot;echo&quot;).add();
config.command(&quot;ping&quot;).add();

// Add the prefix `&quot;!&quot;`.
// (Use `Config::add_prefixes` to add multiple prefixes)
config.add_prefix(&quot;!&quot;);

let parser = Parser::new(config);

// Now pass a command to the parser
match parser.parse(&quot;!echo a message&quot;) {
    Some(Command { name: &quot;echo&quot;, arguments, .. }) =&gt; {
        let content = arguments.as_str();

        println!(&quot;Got an echo request to send `{}`&quot;, content);
    },
    Some(Command { name: &quot;ping&quot;, .. }) =&gt; {
        println!(&quot;Got a ping request&quot;);
    },
    // Ignore all other commands.
    Some(_) =&gt; {},
    None =&gt; println!(&quot;Message didn't match a prefix and command&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#links-4" id="links-4">Links</a></h3>
<p><em>source</em>: <a href="https://github.com/twilight-rs/twilight/tree/master/command-parser">https://github.com/twilight-rs/twilight/tree/master/command-parser</a></p>
<p><em>docs</em>: <a href="https://docs.rs/twilight-command-parser">https://docs.rs/twilight-command-parser</a></p>
<p><em>crates.io</em>: <a href="https://crates.io/crates/twilight-command-parser">https://crates.io/crates/twilight-command-parser</a></p>
<h1><a class="header" href="#twilight" id="twilight">Twilight</a></h1>
<p><code>twilight</code> is the root crate of the entire project. It's what could be called a
&quot;skeleton crate&quot;: all it does is re-export all of the other core crates.</p>
<p>Since all of the crates in Twilight are building blocks, they aren't very
intertwined. This means that they can be used separately without having to bring
in the entire ecosystem of core crates. Most people, though, will need all of
these crates. To create a single unified experience with easy installation, this
crate exists to provide all of them.</p>
<h3><a class="header" href="#source-code" id="source-code">Source Code</a></h3>
<p>This is the entire contents of the library:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;cache&quot;)]
pub extern crate twilight_cache as cache;

#[cfg(feature = &quot;command-parser&quot;)]
pub extern crate twilight_command_parser as command_parser;

#[cfg(feature = &quot;gateway&quot;)]
pub extern crate twilight_gateway as gateway;

#[cfg(feature = &quot;http&quot;)]
pub extern crate twilight_http as http;

#[cfg(feature = &quot;model&quot;)]
pub extern crate twilight_model as model;

#[cfg(feature = &quot;voice&quot;)]
pub extern crate twilight_voice as voice;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#installation-4" id="installation-4">Installation</a></h3>
<p>This library requires at least Rust 1.39+.</p>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">twilight = { git = &quot;https://github.com/twilight-rs/twilight&quot; }
</code></pre>
<h3><a class="header" href="#features-1" id="features-1">Features</a></h3>
<p>All of the crates that are re-exported can be disabled. For example, if you need
everything but <code>voice</code>, then you can disable only voice. This looks like:</p>
<pre><code class="language-toml">[dependencies.twilight]
default-features = false
features = [&quot;cache&quot;, &quot;command-parser&quot;, &quot;gateway&quot;, &quot;http&quot;, &quot;model&quot;]
git = &quot;https://github.com/twilight-rs/twilight&quot;
</code></pre>
<p>This is the list of features, which are all enabled by default:</p>
<ul>
<li><code>cache</code></li>
<li><code>command-parser</code></li>
<li><code>gateway</code></li>
<li><code>http</code></li>
<li><code>model</code></li>
<li><code>voice</code></li>
</ul>
<p>If you're developing a library, it's easier for users to know what you depend on
by depending on the individual crates. If you're making a framework, this might
look like:</p>
<pre><code class="language-toml">[dependencies]
twilight-cache = { git = &quot;https://github.com/twilight-rs/twilight&quot; }
twilight-gateway = { git = &quot;https://github.com/twilight-rs/twilight&quot; }
twilight-http = { git = &quot;https://github.com/twilight-rs/twilight&quot; }
</code></pre>
<h3><a class="header" href="#links-5" id="links-5">Links</a></h3>
<p><em>source</em>: <a href="https://github.com/twilight-rs/twilight">https://github.com/twilight-rs/twilight</a></p>
<p><em>docs</em>: <a href="https://docs.rs/twilight">https://docs.rs/twilight</a></p>
<p><em>crates.io</em>: <a href="https://crates.io/crates/twilight">https://crates.io/crates/twilight</a></p>
<h1><a class="header" href="#first-party" id="first-party">First-party</a></h1>
<p>Twilight has a couple of first-party crates maintained by the organization, but not
included as part of the core experience. These are entirely opt-in, and are for
more advanced use cases or integration with third party software.</p>
<p>Although not a part of the core experience, these are given the same level of
support as the core crates.</p>
<p>The crates are still very much a work in progress and will be published as they are finished.</p>
<h1><a class="header" href="#redis-cache" id="redis-cache">Redis Cache</a></h1>
<p><code>twilight-cache-redis</code> will be an implementation of a cache using Redis as a backend. It
is entirely stateless other than the TCP connection used by <a href="https://docs.rs/redis"><code>redis</code></a> itself.</p>
<p>Read the section on <a href="chapter_1_crates/section_7_first_party/../section_4_cache.html">the cache crate</a> for more information on how this is
implemented.</p>
<h3><a class="header" href="#example-2" id="example-2">Example</a></h3>
<p>Creating a connection to the redis database and getting a guild by ID:</p>
<pre><pre class="playpen"><code class="language-rust">use twilight_cache_redis::RedisCache;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let cache = RedisCache::connect((&quot;0.0.0.0&quot;, 6379)).await?;
    
    if let Some(guild) = cache.guild(620980184606048276).await? {
        println!(&quot;Guild name: {}&quot;, guild.name);
    }

    Ok(())
}
</code></pre></pre>
<h3><a class="header" href="#links-6" id="links-6">Links</a></h3>
<p><strong>source</strong>: <a href="https://github.com/twilight-rs/twilight/tree/master/cache/redis">https://github.com/twilight-rs/twilight/tree/master/cache/redis</a>
<strong>docs</strong>: <a href="https://docs.rs/twilight-cache-redis">https://docs.rs/twilight-cache-redis</a>
<strong>crates.io</strong>: <a href="https://crates.io/crates/twilight-cache-redis">https://crates.io/crates/twilight-cache-redis</a></p>
<h1><a class="header" href="#lavalink" id="lavalink">Lavalink</a></h1>
<p><code>twilight-lavalink</code> will be a client for <a href="https://github.com/Frederikam/Lavalink">Lavalink</a> using <code>twilight-gateway</code>.</p>
<h3><a class="header" href="#links-7" id="links-7">Links</a></h3>
<p><strong>source</strong>: <a href="https://github.com/twilight-rs/twilight/tree/master/lavalink">https://github.com/twilight-rs/twilight/tree/master/lavalink</a>
<strong>docs</strong>: <a href="https://docs.rs/twilight-lavalink">https://docs.rs/twilight-lavalink</a>
<strong>crates.io</strong>: <a href="https://crates.io/crates/twilight-lavalink">https://crates.io/crates/twilight-lavalink</a></p>
<h1><a class="header" href="#third-party" id="third-party">Third-party</a></h1>
<p>Maybe one day there will be third-party crates to mention here.</p>
<p>But right now, there isn't.</p>
<h1><a class="header" href="#building-a-bot" id="building-a-bot">Building a Bot</a></h1>
<p>In this chapter you'll learn what you need to create, compile, write, and run
your bot.</p>
<p>The guide assumes that have experience with Rust, and assumes that you are
caught up on its features, namely <a href="https://rust-lang.github.io/async-book/">async/await</a> support, which was introduced in
Rust 1.39. Also assumed is that you have <a href="https://rustup.rs">rustup</a> installed and understand the
basics on how to use it.</p>
<p>A minimal amount of experience with how Discord bots work is expected, but you
will be guided through how to create a bot user.</p>
<h1><a class="header" href="#preparation" id="preparation">Preparation</a></h1>
<p>You'll need a couple of things before you get started with your bot.</p>
<h3><a class="header" href="#rust-setup" id="rust-setup">Rust Setup</a></h3>
<p>Twilight requires async/await support, which means that you need to have a fairly recent version of rust, 1.40+ should work. If
you haven't installed it, you should. Rust can be installed with <a href="https://rustup.rs">rustup</a>.</p>
<p>Now you'll want to make a project for your bot:</p>
<pre><code class="language-shell">$ cargo new bot-name &amp;&amp; cd $_
</code></pre>
<h3><a class="header" href="#making-a-bot-user" id="making-a-bot-user">Making a Bot User</a></h3>
<blockquote>
<p>If you already know how to do this, feel free to skip to
<a href="chapter_2_building_a_bot/section_1_preparation.html#installing-twilight">Installing Twilight</a>.</p>
</blockquote>
<p>In the <a href="https://discordapp.com/developers/applications/">Discord Developer Portal</a> you'll find a page with a list of your
applications. Odds are if you don't know how to make a bot user, you haven't
before, so this is probably empty.</p>
<p>In the top-right you'll see a blurple <strong>New Application</strong> button. Click it.</p>
<p><img src="chapter_2_building_a_bot/./section_1_new_application.png" alt="New Application button" /></p>
<p>You'll be asked to give your application a name. For the example, we're naming
the application <strong>Kona</strong>. It doesn't matter what you name it, and it can be
changed later.</p>
<p><img src="chapter_2_building_a_bot/./section_1_name.png" alt="Name your bot" /></p>
<p>Now you'll be taken to your new application's page. On the sidebar, click
<strong>Bot</strong>.</p>
<p><img src="chapter_2_building_a_bot/./section_1_sidebar.png" alt="Sidebar" /></p>
<p>Now you'll see a button to <strong>Add a Bot</strong>. Click it. It'll ask if you're
<strong>really sure</strong> if you want to do this. Yeah, you are sure.</p>
<p><img src="chapter_2_building_a_bot/./section_1_build_a_bot.png" alt="Build a bot" /></p>
<p>Finally, you have a bot user. You can change its avatar and its username, so
that's cool, but not really what we need to care about. What you'll need is the
token. This is what will allow you to connect your bot to Discord's APIs. To get
it, click <strong>Copy</strong>.</p>
<blockquote>
<p><strong>Note</strong>: It's <em>very</em>, <strong>very</strong>, <em><strong>very</strong></em> important that you don't give this
token to <em>anybody</em>. If anyone has your token, then they can spam guilds, ban
users, leave all the guilds that the bot is in, burn your house down, and
everything.</p>
</blockquote>
<h1><a class="header" href="#installing-twilight" id="installing-twilight">Installing Twilight</a></h1>
<blockquote>
<p>Since this guide assumes familiarity with Rust already, this guide won't
explain how using Cargo works.</p>
</blockquote>
<p>We're going to add <code>twilight</code> as a dependency, which is the root crate re-exporting
all of the core crates, such as the HTTP and gateway clients, the models,
and cache.</p>
<p>To do that, add the following to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
twilight = { git = &quot;https://github.com/twilight-rs/twilight&quot; }
</code></pre>
<p>Now you're all set to get programming! In the next chapter you'll learn how to
write a simple ping-pong mechanism and why it works.</p>
<h1><a class="header" href="#pong" id="pong">Pong!</a></h1>
<h1><a class="header" href="#have-some-fun" id="have-some-fun">Have Some Fun</a></h1>
<h1><a class="header" href="#basic-moderation" id="basic-moderation">Basic Moderation</a></h1>
<h1><a class="header" href="#services" id="services">Services</a></h1>
<h1><a class="header" href="#why-build-services" id="why-build-services">Why Build Services?</a></h1>
<h1><a class="header" href="#using-an-http-proxy" id="using-an-http-proxy">Using an HTTP Proxy</a></h1>
<h1><a class="header" href="#using-a-redis-cache" id="using-a-redis-cache">Using a Redis Cache</a></h1>
<h1><a class="header" href="#using-a-message-broker" id="using-a-message-broker">Using a Message Broker</a></h1>
<h1><a class="header" href="#using-the-gateway-queue" id="using-the-gateway-queue">Using the Gateway Queue</a></h1>
<p>If your bot's shards are multi-processed, then a good choice is to use the
[Gateway Queue]. The Gateway Queue is a lightweight but powerful application
that you can host to queue shards across all of your processes.</p>
<p>The Gateway Queue is library and language agnostic: it's an HTTP server that you
call whenever a shard needs to reconnect to the gateway.</p>
<h3><a class="header" href="#how-it-works" id="how-it-works">How it works</a></h3>
<p>When one of your shards disconnects and needs to perform a full reconnect, then
it needs to start a new session with the gateway. If you have multiple processes
managing shards, then you may not have communication between these processes.
The problems start to happen when multiple shards from these processes try to
reconnect at the same time: all but 1 will get ratelimited.</p>
<p>This is because there's a 5 second ratelimit between new sessions. By sending an
HTTP request to the Gateway Queue, it will ratelimit the requests and &quot;stall&quot;
them, responding with a friendly message once that shard can reconnect:</p>
<pre><code class="language-json">{&quot;message&quot;: &quot;You're free to connect now! :)&quot;}
</code></pre>
<h3><a class="header" href="#example-3" id="example-3">Example</a></h3>
<p>The API is pretty minimal, probably. It's just an HTTP request:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>reqwest::get(&quot;http://gateway-queue&quot;).await?;
<span class="boring">}
</span></code></pre></pre>
<p>No headers, body, or particular method need to be set. They're all ignored.
The request will get a response once the request has gone through the queue.</p>
<h3><a class="header" href="#running-it" id="running-it">Running it</a></h3>
<p>If you're using Docker, you can clone the repo and run:</p>
<pre><code class="language-sh">$ docker build . -t twilight-gateway-queue
$ docker run -itd -e HOST=0.0.0.0 -e PORT=5000 twilight-gateway-queue 
</code></pre>
<p>If you're not, you can compile it via Cargo:</p>
<pre><code class="language-sh">$ cargo build --release
$ HOST=0.0.0.0 PORT=5000 ./target/release/twilight-gateway-queue
</code></pre>
<p><code>HOST</code> and <code>PORT</code> are the only two environment variables.</p>
<h3><a class="header" href="#links-8" id="links-8">Links</a></h3>
<p><em>source</em>: <a href="https://github.com/twilight-rs/gateway-queue">https://github.com/twilight-rs/gateway-queue</a></p>
<h1><a class="header" href="#moving-forward" id="moving-forward">Moving Forward</a></h1>
<h1><a class="header" href="#bots-using-twilight" id="bots-using-twilight">Bots using Twilight</a></h1>
<p>Below is a list of bots known to be using the Twilight ecosystem. The use could be
as small as only <a href="./chapter_1_crates/section_3_gateway.html">the gateway</a> or <a href="./chapter_3_services/section_2_using_http_proxy.html">HTTP proxy</a>, or as large as all of the
<a href="./chapter_1_crates/summary.html">core crates</a>.</p>
<h3><a class="header" href="#lasagne-bot" id="lasagne-bot">Lasagne bot</a></h3>
<p>Lasagne bot is a bot that posts garfield comics.</p>
<p><em>Source</em>: <a href="https://git.sr.ht/%7Eerk/lasagna">Sr.ht</a></p>
<h1><a class="header" href="#changelogs" id="changelogs">Changelogs</a></h1>
<p>No changes yet! :)</p>
<h1><a class="header" href="#contributors" id="contributors">Contributors</a></h1>
<p>Thanks (a lot!) to the following people for contributing:</p>
<ul>
<li><a href="https://github.com/Arzte">Arzte</a></li>
<li><a href="https://github.com/dvtkrlbs">dvtkrlbs</a></li>
<li><a href="https://github.com/Erk-">Erk</a></li>
<li><a href="https://github.com/HiruNya">HiruNya</a></li>
<li><a href="https://github.com/kalmari246">kalmari246</a></li>
<li><a href="https://github.com/Mathspy">Mathspy</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
